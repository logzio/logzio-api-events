from enum import Enum
import json
import logging
from pydantic import BaseModel, Field, model_validator
from typing import Union

from src.utils.processing_functions import extract_vars, substitute_vars, get_nested_value, break_key_name
from src.apis.general.StopPaginationSettings import StopPaginationSettings

logger = logging.getLogger(__name__)


class PaginationType(Enum):
    """
    Supported Pagination types
    """
    URL = "url"
    BODY = "body"
    HEADERS = "headers"


class PaginationSettings(BaseModel):
    """
    Class that initialize API pagination settings.
    :param pagination_type: Where is the pagination made, url, body or headers.
    :param next_url: If the pagination is in the URL, the url to use and the params to update in it.
    :param update_first_url: If the pagination is in the URL, supports using the original URL and adding new params
                                to it. Example: http://endpoint?date=XXX >> http://endpoint?date=XXX&newParam=YYY
    :param next_headers: If the pagination is in the Headers, the headers to use and the params to update in it.
    :param next_body: If the pagination is in the Body, the body to use and the params to update in it.
    :param stop_indication: StopPaginationSettings object that defines when the pagination should stop
    :param max_calls: The max calls the pagination can make. Max value is 1000.
    :param url_vars, headers_vars, body_vars: Not passed to the class, array of params generated by matching next_XXX
    """
    pagination_type: PaginationType = Field(alias="type")
    next_url: str = Field(default=None, frozen=True, alias="url_format")
    update_first_url: bool = Field(default=False, frozen=True)
    next_headers: dict = Field(default={}, alias="headers_format")
    next_body: Union[str, dict] = Field(default=None, alias="body_format")
    stop_indication: StopPaginationSettings = Field(default=None, frozen=True)
    max_calls: int = Field(default=100, le=1000, frozen=True)
    url_vars: list = Field(default=[], init=False, init_var=True)
    headers_vars: list = Field(default=[], init=False, init_var=True)
    body_vars: list = Field(default=[], init=False, init_var=True)

    def __init__(self, **data):
        """
        Generates the URL,Headers and Body parameters.
        :param data: the fields for creation of the class.
        """
        super().__init__(**data)
        self.url_vars = extract_vars(self.next_url)
        self.headers_vars = extract_vars(self.next_headers)
        self.body_vars = extract_vars(self.next_body)

    @model_validator(mode='after')
    def _check_conditional_fields(self):
        """
        Validates that:
        if type == url >> that we got next_url (or alias url_format)
        if type == headers >> that we got next_headers (or alias headers_format)
        if type == body >> that we got next_body (or alias body_format)
        :return: self
        """
        if ((self.pagination_type == PaginationType.URL and not self.next_url) or
                (self.pagination_type == PaginationType.HEADERS and not self.next_headers) or
                (self.pagination_type == PaginationType.BODY and not self.next_body)):
            raise ValueError(f"Used pagination type {self.pagination_type.value.upper()} but missing required field "
                             f"{self.pagination_type.value}_format")
        return self

    def get_next_url(self, values_dict, prev_url):
        """
        Generates the next URL to use based on replacing the parameters in next_url with the values from given
        values_dict.
        :param values_dict: dictionary with values.
        :param prev_url: URL of the previous request, if needed to only add new params in it and not replace all of it
        :return: next_url with values instead of variables
        """
        new_url = self.next_url
        if self.update_first_url:
            new_url = prev_url + self.next_url
        try:
            return substitute_vars(new_url, self.url_vars, values_dict)
        except ValueError as e:
            logger.warning(f"Failed to update the next URL for the pagination due to error: {e}")
        return None

    def get_next_headers(self, values_dict):
        """
        Generates the next Headers to use based on replacing the parameters in next_url with the values from given
        values_dict.
        :param values_dict: dictionary with values.
        :return: next_headers with values instead of variables
        """
        new_headers = self.next_headers
        for header in self.next_headers:
            try:
                new_headers[header] = substitute_vars(self.next_headers.get(header), self.headers_vars, values_dict)
            except ValueError as e:
                logger.warning(f"Failed to update the next Headers for the pagination due to error: {e}")
        return new_headers

    def get_next_body(self, values_dict):
        """
        Generates the next Body to use based on replacing the parameters in next_url with the values from given
        values_dict.
        :param values_dict: dictionary with values
        :return: next_body with values instead of variables
        """
        new_body = self.next_body
        if not isinstance(self.next_body, str):
            try:
                new_body = json.dumps(self.next_body)
            except json.decoder.JSONDecodeError:
                new_body = str(self.next_body)
        try:
            new_body = substitute_vars(new_body, self.body_vars, values_dict)
        except ValueError as e:
            logger.warning(f"Failed to update the next Body for the pagination due to error: {e}")

        # Revert flattening of object if needed
        if isinstance(self.next_body, dict):
            new_body = json.loads(new_body)
        return new_body

    def did_pagination_end(self, res, call_count):
        """
        Returns True if the pagination should end, False otherwise.
        Decides that we should stop if either of the below:
        1. We reached the Stop indication
        2. We reached the max_calls.
        :param res: The response we got from the last request.
        :param call_count: the current amount of calls that were made.
        :return: True if pagination should stop, False otherwise.
        """
        should_stop = False

        # Check stop indication
        if self.stop_indication:
            should_stop = self.stop_indication.should_stop(get_nested_value(res, break_key_name(self.stop_indication.field)))
            logger.debug(f"Pagination stop status: {should_stop}")

        # If stop indication says to not stop OR there is no stop indication >> stop if we reached the max call count
        if not should_stop:
            should_stop = self.max_calls <= call_count
        return should_stop
